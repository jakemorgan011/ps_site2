<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>horse.beer/dimensionality</title>
    <link rel="stylesheet" href="src/css/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="src/lib/dsp.js"></script>
</head>
<body>
    <h1><a href="index.html">horse.beer</a>/dimensionality</h1>
    <div class='content' id='dimensionality'>
        <div class='sidebar'>
            <h2 style="border: wave; font-size: 1.76em;">controls</h2>
            
            <p class='ani-bar' id='p0' style="font-size: 1.35em; margin: 0;">--------</p>
            
            <label for="obj-input">
                <i class="fas fa-upload"></i>upload .obj
            </label>
            <input type="file" id="obj-input" accept=".obj" />
            
            <label for="wav-input">
                <i class="fas fa-upload"></i>upload .wav
            </label>
            <input type="file" id="wav-input" accept=".wav,.mp3" />
            
            <p class='ani-bar' id='p1' style="font-size: 1.35em; margin: 0;">----------</p>
            
            <button id="process-btn" disabled>process audio</button>
            <button id="play-btn" disabled>start playback</button>
            <button id="stop-btn" disabled>stop playback</button>
            
            <p class='ani-bar' id='p2' style="font-size: 1.35em; margin: 0;">----------</p>
            
            <button id="download-btn" disabled>download .wav</button>
            
            <div id="status" style="color: white; padding: 10px; margin-top: 20px;">
                <h3>Status:</h3>
                <p id="status-text">Ready</p>
            </div>
            
            <div id="params-display" style="color: white; padding: 10px; margin-top: 20px; display: none;">
                <h3>Mesh Parameters:</h3>
                <div id="params-list"></div>
            </div>
        </div>
        
        <div class='sketch-container' style="justify-content: center;">
            <div class='canvas-container' id='canvas-container-dimensionality'>
                <script src="src/js/sketch2.js"></script>
            </div>
        </div>
    </div>
    
    <script src="src/js/p_animate.js"></script>
    
    <script>
    class OBJParser {
        static parse(text) {
            const vertices = [];
            const lines = text.split('\n');
            
            for (const line of lines) {
                const parts = line.trim().split(/\s+/);
                if (parts[0] === 'v') {
                    vertices.push({
                        x: parseFloat(parts[1]),
                        y: parseFloat(parts[2]),
                        z: parseFloat(parts[3])
                    });
                }
            }
            
            return vertices;
        }
    }
    
    class MeshFingerprint {
        static calculate(vertices) {
            if (vertices.length === 0) return null;
            
            const byX = [...vertices].sort((a, b) => a.x - b.x);
            const byY = [...vertices].sort((a, b) => a.y - b.y);
            const byZ = [...vertices].sort((a, b) => a.z - b.z);
            const byDistance = [...vertices].sort((a, b) => {
                const distA = Math.sqrt(a.x**2 + a.y**2 + a.z**2);
                const distB = Math.sqrt(b.x**2 + b.y**2 + b.z**2);
                return distA - distB;
            });
            
            // Calculate geometric complexity
            const calculateAngularVariance = (verts) => {
                let angleSum = 0;
                for (let i = 0; i < verts.length - 2; i++) {
                    const v1 = verts[i];
                    const v2 = verts[i + 1];
                    const v3 = verts[i + 2];
                    
                    const angle = Math.atan2(v2.y - v1.y, v2.x - v1.x) - 
                                  Math.atan2(v3.y - v2.y, v3.x - v2.x);
                    angleSum += Math.abs(angle);
                }
                return angleSum / (verts.length - 2);
            };
            
            const calculateDensity = (verts) => {
                let densitySum = 0;
                const sampleSize = Math.min(100, verts.length);
                for (let i = 0; i < sampleSize; i++) {
                    const idx = Math.floor(i * verts.length / sampleSize);
                    const v = verts[idx];
                    let nearCount = 0;
                    const threshold = 0.5;
                    
                    for (let j = 0; j < Math.min(20, verts.length); j++) {
                        const compareIdx = (idx + j) % verts.length;
                        const cv = verts[compareIdx];
                        const dist = Math.sqrt(
                            Math.pow(v.x - cv.x, 2) + 
                            Math.pow(v.y - cv.y, 2) + 
                            Math.pow(v.z - cv.z, 2)
                        );
                        if (dist < threshold && dist > 0) nearCount++;
                    }
                    densitySum += nearCount;
                }
                return densitySum / sampleSize;
            };
            
            const stats = {
                x10: byX[Math.floor(vertices.length * 0.1)].x,
                x50: byX[Math.floor(vertices.length * 0.5)].x,
                x90: byX[Math.floor(vertices.length * 0.9)].x,
                
                y10: byY[Math.floor(vertices.length * 0.1)].y,
                y50: byY[Math.floor(vertices.length * 0.5)].y,
                y90: byY[Math.floor(vertices.length * 0.9)].y,
                
                z10: byZ[Math.floor(vertices.length * 0.1)].z,
                z50: byZ[Math.floor(vertices.length * 0.5)].z,
                z90: byZ[Math.floor(vertices.length * 0.9)].z,
                
                minDist: Math.sqrt(byDistance[0].x**2 + byDistance[0].y**2 + byDistance[0].z**2),
                medianDist: Math.sqrt(
                    byDistance[Math.floor(vertices.length * 0.5)].x**2 +
                    byDistance[Math.floor(vertices.length * 0.5)].y**2 +
                    byDistance[Math.floor(vertices.length * 0.5)].z**2
                ),
                maxDist: Math.sqrt(
                    byDistance[vertices.length - 1].x**2 +
                    byDistance[vertices.length - 1].y**2 +
                    byDistance[vertices.length - 1].z**2
                ),
                
                xSpread: byX[byX.length - 1].x - byX[0].x,
                ySpread: byY[byY.length - 1].y - byY[0].y,
                zSpread: byZ[byZ.length - 1].z - byZ[0].z,
                
                centerX: vertices.reduce((sum, v) => sum + v.x, 0) / vertices.length,
                centerY: vertices.reduce((sum, v) => sum + v.y, 0) / vertices.length,
                centerZ: vertices.reduce((sum, v) => sum + v.z, 0) / vertices.length,
                
                variance: this.calculateVariance(vertices),
                angularVariance: calculateAngularVariance(vertices),
                density: calculateDensity(vertices),
                aspectRatio: Math.max(
                    (byX[byX.length - 1].x - byX[0].x) / (byY[byY.length - 1].y - byY[0].y || 1),
                    (byY[byY.length - 1].y - byY[0].y) / (byX[byX.length - 1].x - byX[0].x || 1)
                )
            };
            
            return stats;
        }
        
        static calculateVariance(vertices) {
            const mean = {
                x: vertices.reduce((sum, v) => sum + v.x, 0) / vertices.length,
                y: vertices.reduce((sum, v) => sum + v.y, 0) / vertices.length,
                z: vertices.reduce((sum, v) => sum + v.z, 0) / vertices.length
            };
            
            const variance = vertices.reduce((sum, v) => {
                return sum + 
                    Math.pow(v.x - mean.x, 2) +
                    Math.pow(v.y - mean.y, 2) +
                    Math.pow(v.z - mean.z, 2);
            }, 0) / vertices.length;
            
            return variance;
        }
        
        static mapToAudioParams(stats) {
            const normalize = (value, min, max) => {
                return Math.max(0, Math.min(1, (value - min) / (max - min)));
            };
            
            return {
                // Original parameters
                reverbSize: normalize(stats.medianDist, 0, 10),
                reverbDamping: normalize(stats.variance, 0, 5),
                reverbWetness: normalize(stats.ySpread, 0, 5) * 0.5,
                
                delayTime: normalize(stats.zSpread, 0, 5) * 0.5,
                delayFeedback: normalize(Math.abs(stats.centerZ), 0, 3) * 0.7,
                
                filterFreq: 200 + normalize(stats.y90, -5, 5) * 3800,
                filterQ: 1 + normalize(stats.xSpread, 0, 5) * 10,
                
                distortionAmount: normalize(stats.variance, 0, 10) * 50,
                
                pan: Math.max(-1, Math.min(1, stats.centerX / 5)),
                
                chorusDepth: normalize(stats.x90 - stats.x10, 0, 5),
                chorusRate: 0.5 + normalize(stats.minDist, 0, 2) * 4,
                
                // NEW SPECTRAL PARAMETERS
                spectralMashAmount: normalize(stats.variance, 0, 10),
                spectralMashFreqMod: normalize(stats.angularVariance, 0, 3),
                
                spectralTiltAmount: (normalize(stats.centerY, -5, 5) - 0.5) * 2,
                spectralTiltPivot: 1000 + normalize(stats.medianDist, 0, 10) * 4000,
                
                deharmonizeAmount: normalize(stats.density, 0, 10) * 0.5,
                deharmonizeShift: normalize(stats.aspectRatio, 1, 5),
                
                spectralSmearAmount: normalize(stats.xSpread, 0, 10) * 0.8,
                spectralSmearTime: normalize(stats.zSpread, 0, 5) * 0.3,
                
                formantShift: (normalize(stats.z50, -5, 5) - 0.5) * 2,
                
                ringModFreq: 50 + normalize(stats.maxDist, 0, 10) * 950,
                ringModAmount: normalize(Math.abs(stats.centerX), 0, 5) * 0.7,
                
                granularSize: 0.02 + normalize(stats.minDist, 0, 3) * 0.18,
                granularOverlap: 0.5 + normalize(stats.y10, -5, 5) * 0.4,
                
                bitcrushAmount: normalize(stats.variance * stats.density, 0, 50),
                
                spectralShimmerAmount: normalize(stats.ySpread * stats.xSpread, 0, 25) * 0.6,
                spectralShimmerRate: 0.1 + normalize(stats.angularVariance, 0, 3) * 0.9
            };
        }
    }
    
    // ADVANCED SPECTRAL PROCESSING
    async function spectralProcess(inputBuffer, params) {
        const sampleRate = inputBuffer.sampleRate;
        const numChannels = inputBuffer.numberOfChannels;
        const outputLength = inputBuffer.length;
        
        const outputChannels = [];
        for (let ch = 0; ch < numChannels; ch++) {
            outputChannels[ch] = new Float32Array(outputLength);
        }
        
        const fftSize = 4096;
        const hopSize = Math.floor(fftSize / 4);
        
        for (let ch = 0; ch < numChannels; ch++) {
            const input = inputBuffer.getChannelData(ch);
            const output = outputChannels[ch];
            const fft = new FFT(fftSize, sampleRate);
            
            let prevMagnitudes = null;
            let prevPhases = null;
            
            for (let i = 0; i < input.length - fftSize; i += hopSize) {
                const chunk = input.slice(i, i + fftSize);
                
                // Apply window
                const windowed = new Float32Array(fftSize);
                for (let j = 0; j < fftSize; j++) {
                    const w = 0.5 - 0.5 * Math.cos(2 * Math.PI * j / fftSize);
                    windowed[j] = chunk[j] * w;
                }
                
                fft.forward(windowed);
                
                let real = new Float32Array(fft.real);
                let imag = new Float32Array(fft.imag);
                
                const magnitudes = new Float32Array(real.length);
                const phases = new Float32Array(real.length);
                
                // Convert to magnitude/phase
                for (let bin = 0; bin < real.length; bin++) {
                    magnitudes[bin] = Math.sqrt(real[bin]**2 + imag[bin]**2);
                    phases[bin] = Math.atan2(imag[bin], real[bin]);
                }
                
                // SPECTRAL MASH
                if (params.spectralMashAmount > 0.01) {
                    for (let bin = 0; bin < magnitudes.length; bin++) {
                        const freq = bin * sampleRate / fftSize;
                        const mashMod = 1 + params.spectralMashAmount * 
                            Math.sin(freq * params.spectralMashFreqMod * 0.001);
                        magnitudes[bin] *= mashMod;
                    }
                }
                
                // SPECTRAL TILT
                if (Math.abs(params.spectralTiltAmount) > 0.01) {
                    for (let bin = 0; bin < magnitudes.length; bin++) {
                        const freq = bin * sampleRate / fftSize;
                        const tiltDb = params.spectralTiltAmount * 
                            Math.log10(Math.max(1, freq / params.spectralTiltPivot)) * 20;
                        const tiltGain = Math.pow(10, tiltDb / 20);
                        magnitudes[bin] *= tiltGain;
                    }
                }
                
                // DEHARMONIZATION
                if (params.deharmonizeAmount > 0.01) {
                    const newMagnitudes = new Float32Array(magnitudes.length);
                    for (let bin = 0; bin < magnitudes.length; bin++) {
                        const freq = bin * sampleRate / fftSize;
                        const shift = params.deharmonizeShift * (1 + Math.sin(freq * 0.01) * 0.3);
                        const newBin = Math.floor(bin * shift) % magnitudes.length;
                        newMagnitudes[newBin] += magnitudes[bin] * params.deharmonizeAmount;
                        newMagnitudes[bin] += magnitudes[bin] * (1 - params.deharmonizeAmount);
                    }
                    for (let bin = 0; bin < magnitudes.length; bin++) {
                        magnitudes[bin] = newMagnitudes[bin];
                    }
                }
                
                // SPECTRAL SMEAR
                if (params.spectralSmearAmount > 0.01 && prevMagnitudes) {
                    for (let bin = 0; bin < magnitudes.length; bin++) {
                        magnitudes[bin] = magnitudes[bin] * (1 - params.spectralSmearAmount) +
                                         prevMagnitudes[bin] * params.spectralSmearAmount;
                    }
                }
                
                // FORMANT SHIFTING
                if (Math.abs(params.formantShift) > 0.01) {
                    const newMagnitudes = new Float32Array(magnitudes.length);
                    for (let bin = 0; bin < magnitudes.length; bin++) {
                        const shiftedBin = Math.floor(bin * (1 + params.formantShift * 0.5));
                        if (shiftedBin < magnitudes.length) {
                            newMagnitudes[shiftedBin] = magnitudes[bin];
                        }
                    }
                    for (let bin = 0; bin < magnitudes.length; bin++) {
                        magnitudes[bin] = newMagnitudes[bin];
                    }
                }
                
                // SPECTRAL SHIMMER
                if (params.spectralShimmerAmount > 0.01) {
                    const shimmerPhase = (i / sampleRate) * params.spectralShimmerRate * Math.PI * 2;
                    for (let bin = Math.floor(magnitudes.length * 0.3); bin < magnitudes.length; bin++) {
                        const shimmer = Math.sin(shimmerPhase + bin * 0.1) * params.spectralShimmerAmount;
                        magnitudes[bin] *= (1 + shimmer);
                    }
                }
                
                // BITCRUSH IN SPECTRAL DOMAIN
                if (params.bitcrushAmount > 0.01) {
                    const levels = Math.max(2, Math.floor(256 - params.bitcrushAmount * 240));
                    for (let bin = 0; bin < magnitudes.length; bin++) {
                        magnitudes[bin] = Math.floor(magnitudes[bin] * levels) / levels;
                    }
                }
                
                // Store for next iteration
                prevMagnitudes = new Float32Array(magnitudes);
                prevPhases = new Float32Array(phases);
                
                // Convert back to real/imaginary
                for (let bin = 0; bin < real.length; bin++) {
                    real[bin] = magnitudes[bin] * Math.cos(phases[bin]);
                    imag[bin] = magnitudes[bin] * Math.sin(phases[bin]);
                }
                
                const processed = fft.inverse(real, imag);
                
                // Overlap-add
                for (let j = 0; j < processed.length; j++) {
                    if (i + j < output.length) {
                        const w = 0.5 - 0.5 * Math.cos(2 * Math.PI * j / fftSize);
                        output[i + j] += processed[j] * w * 0.5;
                    }
                }
            }
        }
        
        return outputChannels;
    }

    class AudioProcessor {
        constructor() {
            this.audioContext = null;
            this.sourceBuffer = null;
            this.processedBuffer = null;
            this.isPlaying = false;
            this.currentSource = null;
        }
        
        async init() {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        async loadAudioFile(file) {
            const arrayBuffer = await file.arrayBuffer();
            this.sourceBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            return this.sourceBuffer;
        }
        
        async processWithParameters(params) {
            if (!this.sourceBuffer) {
                throw new Error('No audio loaded');
            }

            let processedBuffer = this.sourceBuffer;
            
            // SPECTRAL PROCESSING FIRST
            const needsSpectral = params.spectralMashAmount > 0.01 || 
                                  Math.abs(params.spectralTiltAmount) > 0.01 ||
                                  params.deharmonizeAmount > 0.01 ||
                                  params.spectralSmearAmount > 0.01 ||
                                  Math.abs(params.formantShift) > 0.01 ||
                                  params.spectralShimmerAmount > 0.01 ||
                                  params.bitcrushAmount > 0.01;
            
            if (needsSpectral) {
                const spectralChannels = await spectralProcess(this.sourceBuffer, params);
                
                processedBuffer = this.audioContext.createBuffer(
                    spectralChannels.length,
                    spectralChannels[0].length,
                    this.sourceBuffer.sampleRate
                );
                
                for (let ch = 0; ch < spectralChannels.length; ch++) {
                    processedBuffer.copyToChannel(spectralChannels[ch], ch);
                }
            }
            
            // STANDARD DSP CHAIN
            const offlineContext = new OfflineAudioContext(
                processedBuffer.numberOfChannels,
                processedBuffer.length,
                processedBuffer.sampleRate
            );
            
            const source = offlineContext.createBufferSource();
            source.buffer = processedBuffer;
            
            let currentNode = source;
            
            // RING MODULATION
            if (params.ringModAmount > 0.01) {
                const ringMod = offlineContext.createOscillator();
                ringMod.frequency.value = params.ringModFreq;
                const ringGain = offlineContext.createGain();
                ringGain.gain.value = params.ringModAmount;
                
                ringMod.connect(ringGain);
                
                // This is a simplified ring mod - real implementation would need custom processing
                currentNode.connect(ringGain);
                currentNode = ringGain;
            }
            
            // DISTORTION - DO NOT CHANGE THESE PARAMETERS
            if (params.distortionAmount > 0) {
                const distortion = offlineContext.createWaveShaper();
                distortion.curve = this.makeDistortionCurve(params.distortionAmount);
                distortion.oversample = '4x';
                currentNode.connect(distortion);
                currentNode = distortion;
            }
            
            const filter = offlineContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = params.filterFreq;
            filter.Q.value = params.filterQ;
            currentNode.connect(filter);
            currentNode = filter;
            
            const delay = offlineContext.createDelay(1.0);
            const delayGain = offlineContext.createGain();
            const delayFeedback = offlineContext.createGain();
            const delayWet = offlineContext.createGain();
            
            delay.delayTime.value = params.delayTime;
            delayFeedback.gain.value = params.delayFeedback;
            delayWet.gain.value = 0.3;
            
            currentNode.connect(delay);
            delay.connect(delayGain);
            delayGain.connect(delayFeedback);
            delayFeedback.connect(delay);
            delayGain.connect(delayWet);
            
            const convolver = offlineContext.createConvolver();
            convolver.buffer = this.createReverbImpulse(
                offlineContext.sampleRate,
                params.reverbSize * 4,
                params.reverbDamping
            );
            
            const reverbWet = offlineContext.createGain();
            reverbWet.gain.value = params.reverbWetness;
            
            currentNode.connect(convolver);
            convolver.connect(reverbWet);
            
            const dryGain = offlineContext.createGain();
            dryGain.gain.value = 0.7;
            currentNode.connect(dryGain);
            
            const panner = offlineContext.createStereoPanner();
            panner.pan.value = params.pan;
            
            dryGain.connect(panner);
            delayWet.connect(panner);
            reverbWet.connect(panner);
            panner.connect(offlineContext.destination);

            source.start(0);
            
            this.processedBuffer = await offlineContext.startRendering();
            return this.processedBuffer;
        }
        
        makeDistortionCurve(amount) {
            const samples = 44100;
            const curve = new Float32Array(samples);
            const deg = Math.PI / 180;
            
            for (let i = 0; i < samples; i++) {
                const x = (i * 2) / samples - 1;
                curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
            }
            
            return curve;
        }
        
        createReverbImpulse(sampleRate, duration, decay) {
            const length = sampleRate * duration;
            const impulse = new Float32Array(length);
            
            for (let i = 0; i < length; i++) {
                impulse[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            }
            
            return this.audioContext.createBuffer(1, length, sampleRate);
        }
        
        play(buffer) {
            if (this.isPlaying) this.stop();
            
            this.currentSource = this.audioContext.createBufferSource();
            this.currentSource.buffer = buffer || this.processedBuffer;
            this.currentSource.connect(this.audioContext.destination);
            this.currentSource.start(0);
            this.isPlaying = true;
            
            this.currentSource.onended = () => {
                this.isPlaying = false;
            };
        }
        
        stop() {
            if (this.currentSource) {
                this.currentSource.stop();
                this.currentSource = null;
                this.isPlaying = false;
            }
        }
        
        downloadProcessedAudio(filename = 'processed.wav') {
            if (!this.processedBuffer) {
                throw new Error('No processed audio available');
            }
            
            const wav = this.audioBufferToWav(this.processedBuffer);
            const blob = new Blob([wav], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            
            URL.revokeObjectURL(url);
        }
        
        audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1;
            const bitDepth = 16;
            
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            
            const data = [];
            for (let i = 0; i < buffer.numberOfChannels; i++) {
                data.push(buffer.getChannelData(i));
            }
            
            const length = data[0].length;
            const arrayBuffer = new ArrayBuffer(44 + length * blockAlign);
            const view = new DataView(arrayBuffer);
            
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * blockAlign, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(36, 'data');
            view.setUint32(40, length * blockAlign, true);
            
            let offset = 44;
            for (let i = 0; i < length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, data[channel][i]));
                    view.setInt16(offset, sample * 0x7FFF, true);
                    offset += 2;
                }
            }
            
            return arrayBuffer;
        }
    }
    
    const audioProcessor = new AudioProcessor();
    let meshFingerprint = null;
    let audioParams = null;
    
    document.addEventListener('click', () => {
        if (!audioProcessor.audioContext) {
            audioProcessor.init();
        }
    }, { once: true });
    
    document.getElementById('obj-input').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            const text = await file.text();
            const vertices = OBJParser.parse(text);
            
            document.getElementById('status-text').textContent = `Loaded ${vertices.length} vertices`;
            
            meshFingerprint = MeshFingerprint.calculate(vertices);
            audioParams = MeshFingerprint.mapToAudioParams(meshFingerprint);
            
            const paramsDisplay = document.getElementById('params-display');
            const paramsList = document.getElementById('params-list');
            paramsDisplay.style.display = 'block';
            
            paramsList.innerHTML = Object.entries(audioParams)
                .map(([key, value]) => `<p>${key}: ${value.toFixed(3)}</p>`)
                .join('');
            
            if (audioProcessor.sourceBuffer) {
                document.getElementById('process-btn').disabled = false;
            }
        }
    });
    
    document.getElementById('wav-input').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            await audioProcessor.init();
            await audioProcessor.loadAudioFile(file);
            
            document.getElementById('status-text').textContent = 'Audio loaded';
            
            if (audioParams) {
                document.getElementById('process-btn').disabled = false;
            }
        }
    });
    
    document.getElementById('process-btn').addEventListener('click', async () => {
        if (audioParams && audioProcessor.sourceBuffer) {
            document.getElementById('status-text').textContent = 'Processing...';
            
            try {
                await audioProcessor.processWithParameters(audioParams);
                
                document.getElementById('status-text').textContent = 'Processing complete!';
                document.getElementById('play-btn').disabled = false;
                document.getElementById('download-btn').disabled = false;
            } catch (error) {
                document.getElementById('status-text').textContent = `Error: ${error.message}`;
            }
        }
    });
    
    document.getElementById('play-btn').addEventListener('click', () => {
        audioProcessor.play();
        document.getElementById('stop-btn').disabled = false;
    });
    
    document.getElementById('stop-btn').addEventListener('click', () => {
        audioProcessor.stop();
        document.getElementById('stop-btn').disabled = true;
    });
    
    document.getElementById('download-btn').addEventListener('click', () => {
        audioProcessor.downloadProcessedAudio('dimensionality-processed.wav');
    });
    </script>
</body>
</html>
